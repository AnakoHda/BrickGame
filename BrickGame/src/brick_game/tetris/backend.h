#include "../../gui/cli/frontend.h"
#define GET_USER_INPUT getch()
#define MAX_LVL 10
/// @brief инициализация окна ncurses, отключение отобрадения нажатой клавиши,
/// enter не нужен, скрытие курсора, включение специальных клавиш клавиатуры,
/// если ничего не нажато возвращает ERR, время ожидания ввода getch()
#define WIN_INIT(time)     \
  {                        \
    initscr();             \
    noecho();              \
    cbreak();              \
    curs_set(0);           \
    keypad(stdscr, TRUE);  \
    nodelay(stdscr, TRUE); \
    timeout(time);         \
  }
/// @brief функция изменяет полученный сигнал в более понятный для нас вид в
/// виде enum UserAction_t
/// @param user_input - значение полученное из getch() значение
/// @return  UserAction_t обрабатываемые значения клавиш
UserAction_t get_signal(int user_input);
/** Функция `userInput` принимает на вход пользовательское действие `action` и
 * дополнительный параметр `hold`, который отвечает за зажатие клавиши.
 */
void userInput(UserAction_t action, bool hold);
/**
Функция `updateCurrentState` предназначена для получения данных дляотрисовки
в интерфейсе. Она возвращает структуру, содержащую информацию о текущем
состоянии игры. Например, для тетриса истечение таймера приводит к смещению
фигуры вниз на один ряд. Эта функция должна вызываться из интерфейса с
некоторой периодичностью для поддержания интерфейса в актуальном состоянии.
 */
GameInfo_t updateCurrentState(void);
/// @brief основнаяя функция игрового процесса, запускается из main.c
/// @param
void game_loop(void);
/// @brief начальная функция игрового процесса отображающая начальный экран и
/// переходит в состояние game_state SPAWN_state после передачи нажатой клавиши
/// start
/// @param action - нажатие клавиши
/// @return возвращает новое сосотояние игры
game_state start_state(UserAction_t action);
/// @brief функция состояни игры SPAWN_state, генерирует новый блок, если
/// получилось переходит в следующее состояние MOVING_state, если не получилось
/// переходит в состояние GAMEOVER_state
/// @param
/// @return возвращает новое сосотояние игры
game_state spawn_state(void);
/// @brief основное состояние движения фигуры, реагирует на все виды клавиш
/// движения (лево, право, вниз, поворот),также за переход в состояние
/// PAUSE_state, при достижении определённого времени возвращает новое состояние
/// игры FALLING_state
/// @param action нажатая клавиша
/// @return возвращает новое сосотояние игры
game_state moving_state(UserAction_t action);
/// @brief функция изменения позиции фигуры, реагирует на все виды клавиш также
/// как и MOVING_state, пытается опустить фигуру на позицию ниже, если
/// получилось, возвращает состояние MOVING_state, если не получилось возвращает
/// состояние FALLING_state
/// @param action нажатая клавиша
/// @return возвращает новое сосотояние игры
game_state falling_state(UserAction_t action);
/// @brief функция внесения состояния кубика в игровое поле, также проверяет
/// полные строки, очищает, опускает и подсчитывает очки и уровень
/// @param
/// @return возвращает MOVING_state
game_state connected_state(void);
/// @brief функция завершения игры отображает сообщение об окончании игры и
/// очищает основное игровое поле, после чего возвращает состояние игры
/// START_state
/// @param
/// @return возвращает START_state
game_state gameover_state(void);
/// @brief  функция проверки коллизий основного поля и фигуры activ_brick
/// (проверяет выход за границы и наложение)
/// @param
/// @return возвращает количество коллизий (наложени)
int check_collisions(void);
/// @brief функция добавления фигуры на игровое поле
/// @param
void add_brick_on_board(void);
/// @brief функция поворота фигуры(пытается повернуть), внутри себя включает
/// try_wall_kick, которая пытается повернуть фигуру в стенкую. изменяет позицию
/// и поворот фигуры если получилось, не изменяет если не получилось
/// @param
/// @return возвращет TRUE если фигура повернулась FALSE если не повернулась
int rotate_brick(void);
/// @brief функция отскока от стены, изменяет позицию фигуры если получилось, не
/// изменяет если не получилось
/// @param
/// @return TRUE если  FALSE
int try_wall_kick(void);
/// @brief функция изменяющая позицию фигуры
/// @param action направление сдвига фигуры (включая Up)
void move_brick(UserAction_t action);
/// @brief попытка сдвинуть фигуру, если получилось изменяет позицию, если нет,
/// оставляет без изменнения
/// @param action направление сдвига фигуры
/// @return усли получилось TRUE, если неполучилось FALSE
int try_move_brick(UserAction_t action);
/// @brief функция опускания линий игрового поля на num_lines, проходит снизу
/// вверх и при нахождении пустой строки опускает все вышестоящие строки на -1,
/// а 0 заполняет 0
/// @param num_lines количесвто опускаемых строк
void drop_lines(int num_lines);
/// @brief функция опускания всел строк игрового поля на одну относительно
/// index_line
/// @param index_line индекс относительно которого опускается вышестоящие строки
void drop_line(int index_line);
/// @brief функция очистки строки игрового поля, заполняет его 0
/// @param index_line индекс строки которую необходимо очистить
void clean_line(int index_line);
/// @brief функция по нахождению всех полных строк и их очистке
/// @param
/// @return возвращает поличество очищенных строк
int clean_full_lines(void);
/// @brief Функция инициализации игрового поля(выделения памяти и загрузки
/// HI_SCORE)
void init_game_info(void);
/// @brief Освобождает память игрового поля.
void free_game_info(void);
